// AnyPWM by Nick Borko
// This work is licensed under a Creative Commons
// Attribution-ShareAlike 3.0 Unported License

// Manually do PWM using FlexiTimer2
// (http://www.arduino.cc/playground/Main/FlexiTimer2)
#include <FlexiTimer2.h>

// LED to pulse (non-PWM pin)
#define LED 13

// Period of the PWM wave (and therefore the number of levels)
#define PERIOD 256

namespace AnyPWM {
  extern volatile byte pinLevel[12];
  extern boolean state[12];
  extern byte timer[12];
  void pulse();
  void analogWrite(byte pin, byte level);
  void init();
}

// Variables to keep track of the pin states
volatile byte AnyPWM::pinLevel[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
boolean AnyPWM::state[12] = { LOW, LOW, LOW, LOW, LOW, LOW, LOW, LOW, LOW, LOW, LOW, LOW };
byte AnyPWM::timer[12] = { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };

// Set a digital out pin to a specific level
void AnyPWM::analogWrite(byte pin, byte level) {
  if (pin > 1 && pin < 14 && level >= 0 && level < PERIOD) {
    pin -= 2;
    AnyPWM::pinLevel[pin] = level;
    if (level == 0) {
      // reset the PWM state
      AnyPWM::state[pin] = LOW;
      AnyPWM::timer[pin] = 255;
      digitalWrite(pin + 2, LOW);
    }
  }
}

// Initialize the timer routine; must be called before calling
// AnyPWM::analogWrite!
void AnyPWM::init() {
  // (PERIOD * 48) Hertz seems to be a high enough frequency to produce
  // a steady PWM signal on all 12 output pins
  FlexiTimer2::set(1, 1.0/(PERIOD * 48), AnyPWM::pulse);
  FlexiTimer2::start();
}

// Routine to emit the PWM on the pins
void AnyPWM::pulse() {
  for(int i = 0; i < 12; i += 1) {
    if (AnyPWM::pinLevel[i]) {
      if (AnyPWM::timer[i] == 0) {
        AnyPWM::timer[i] = (AnyPWM::state[i] = !AnyPWM::state[i]) ? AnyPWM::pinLevel[i] : (byte)PERIOD - AnyPWM::pinLevel[i];
      } else {
        digitalWrite(i + 2, AnyPWM::state[i]);
      }
      AnyPWM::timer[i] -= 1;
    }
  }
}

void setup() {
  AnyPWM::init();       // initialize the PWM timer
  pinMode(LED, OUTPUT); // declare LED pin to be an output
}

byte brightness = 0;    // how bright the LED is
byte fadeAmount = 5;    // how many points to fade the LED by

void loop() {
  // set the brightness of the LED:
  AnyPWM::analogWrite(LED, brightness);

  // change the brightness for next time through the loop:
  brightness = brightness + fadeAmount;

  // reverse the direction of the fading at the ends of the fade: 
  if (brightness == 0 || brightness == 255) {
    fadeAmount = -fadeAmount;
  }
  // wait for 30 milliseconds to see the dimming effect
  delay(30);
}
