#include <TinyPinChange.h>

#define LED_PIN             1

#define FIRST_INPUT         2//0
#define SECOND_INPUT        3//5

/* Ci-dessous, choisir EDGE_TYPE entre rien (#define EDGE_TYPE), Falling (#define EDGE_TYPE Falling) ou Rising (#define EDGE_TYPE Rising) */
#define EDGE_TYPE           Rising

/*  vvv  Ne rien modifier aux 3 macros ci-dessous vvv */
#define CONCAT3_(a, b, c)   a##b##c
#define CONCAT3(a, b, c)    CONCAT3_(a, b, c)
#define TINY_PIN_CHANGE     CONCAT3(TinyPinChange_, EDGE_TYPE,  Edge)
/*  ^^^  Ne rien modifier aux 3 macros ci-dessus  ^^^ */

volatile uint16_t FirstInputChangeCount  = 0; /* Volatile since the variable will be updated in interruption */
volatile uint16_t SecondInputChangeCount = 0; /* Volatile since the variable will be updated in interruption */


uint8_t VirtualPortNb;
uint8_t VirtualPortNb_;

void setup()
{
  TinyPinChange_Init();

  Serial.begin(115200); /* Trick: use a "high" data rate (less time wasted in ISR and for transmitting each character) */

  VirtualPortNb  = TinyPinChange_RegisterIsr(FIRST_INPUT,  InterruptFunctionToCall);
  VirtualPortNb_ = TinyPinChange_RegisterIsr(SECOND_INPUT, InterruptFunctionToCall);

  /* Enable Pin Change for each pin */
  TinyPinChange_EnablePin(FIRST_INPUT);
  TinyPinChange_EnablePin(SECOND_INPUT);

  Serial.println(F("\n*** Tiny PinChange Demo (Edge, Rising or Falling edges) ***"));
  Serial.print(F("Pin "));Serial.print((int)FIRST_INPUT);
  Serial.print(F(" is part of virtual port "));Serial.println((int)VirtualPortNb);

  Serial.print(F("Pin "));Serial.print((int)SECOND_INPUT);
  Serial.print(F(" is part of virtual port "));Serial.println((int)VirtualPortNb_);

  Serial.println(F("As you can see, virtual port is always port 0 for ATtiny85"));
  Serial.println(F("Remember <TinyPinChange> is also designed for UNO, MEGA, ATtiny84 and ATtiny167 ;-)"));
  Serial.println(F("Type 1 to start display, 0 to stop display"));
 
  pinMode(LED_PIN, OUTPUT);
 
}

/* Function called in interruption in case of change on pins */
void InterruptFunctionToCall(void)
{
    if(TINY_PIN_CHANGE(VirtualPortNb, FIRST_INPUT)) /* Check FIRST_INPUT has changed (falling or rising edge) */
    {
        FirstInputChangeCount++; /* Rising AND Falling edges are counted */
    }
   
    if(TINY_PIN_CHANGE(VirtualPortNb_, SECOND_INPUT)) /* Check SECOND_INPUT has changed (falling or rising edge) */
    {
        SecondInputChangeCount++; /* Rising AND Falling edges are counted */
    }
}

void loop()
{
static boolean State = HIGH, DisplayEnabled = true;
static uint32_t LedStartMs = millis(), DisplayStartMs = millis();
uint16_t LocalFirstInputChangeCount;
uint16_t LocalSecondInputChangeCount;

  /* Blink the built-in LED */
  if(millis() - LedStartMs >= 500UL)
  {
    LedStartMs = millis();
    digitalWrite(LED_PIN, State);
    State = !State; /* State will be inverted at the next digitalWrite() */
  }
 
  /* Get command from Serial */
  if(Serial.available())
  {
    switch(Serial.read())
    {
      case '0':
      DisplayEnabled = false;
      break;
     
      case '1':
      DisplayEnabled = true;
      break;
    }
  }

  /* Diplay Transition numbers every second */
  if((millis() - DisplayStartMs >= 1000UL) && DisplayEnabled)
  {
    DisplayStartMs = millis();
    noInterrupts(); /* Mandatory since counters are 16 bits */
    LocalFirstInputChangeCount = FirstInputChangeCount;
    LocalSecondInputChangeCount = SecondInputChangeCount;
    interrupts();
    Serial.print(F("FirstInputChangeCount ="));Serial.println(LocalFirstInputChangeCount);
    Serial.print(F("SecondInputChangeCount="));Serial.println(LocalSecondInputChangeCount);
  }
 
}
