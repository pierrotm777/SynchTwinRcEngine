// Inclusion des librairies
#include <Wire.h>
#include <LiquidCrystal.h>
LiquidCrystal lcd(9, 8, 7, 6, 5, 4); // Initialisation de la librairie Liquid Crystal
#include <SD.h>
#include "RTClib.h"
#include "LcdBigFont.h"


RTC_DS1307 RTC; //initialisation de la librairie du module RTC

int tmpPin = A0;    // Selection de l'entrée analogique pour la sonde température TMP36
int jaugePin = A1; // Jauge d'essence sur A1
int lastJauge=500000; // initialisation impossible pour la comparaison de jauge
float vitesse = 0; // initialisation de la vitesse float
int intVitesse=0; // initialisation de la vitesse à afficher (int)
float temperature[10]; // tableau de valeur pour stocker 10 echantillons de température
int index=0 ;          // index du tableau pour s'y retrouver
long previousMillis = 0;       
long interval = 3000; // interval de defilement des parametres sur le lcd
int lcdState = 0;  // parametre en cours d'affichage
volatile byte rpmcount; // compteur tours de roues
float kmcount=0; // compteur de km
char kmprev[10]; // tableau pour lire la carte SD
int bufPos = 0; // buffer pour lire la carte SD
char byteIn = 0; // byte de la carte SD
String erreur=""; // code erreur

unsigned int rpm;
unsigned long timeold; // marqueur de temps
const int chipSelect = 10; // pin cs de la carte SD

void setup() {
// Configuration de l'afficheur 16 caractères en 2 lignes 
lcd.begin(16, 2);
// creation des caracteres speciaux
bigFontBegin();

// Lien avec l'horloge RTC
Wire.begin();
RTC.begin();

memset(kmprev,0,sizeof(kmprev)); 

erreur = "Init";//initialize
// make sure that the default chip select pin is set to
// output, even if you don't use it:
pinMode(10, OUTPUT);

// see if the card is present and can be initialized:
if (!SD.begin(chipSelect)) {
  erreur = "SD";//Card failed, or not present"
  // don't do anything more:
  return;
}

// on lit le nombre de km parcouru jusqu'ici
File dataFile = SD.open("datalog.txt");

// if the file is available, write to it:
if (dataFile) {
  while (dataFile.available()) {

     byteIn = dataFile.read();
if (bufPos < sizeof(kmprev))
kmprev[bufPos++] = byteIn;
  }
  dataFile.close();
  kmcount = strtod(kmprev, NULL);
}  
// if the file isn't open, pop up an error:
else {
  erreur = "File";//error opening datalog.txt
} 
// On verifie la présence de l'horloge, de sa pile...
if (! RTC.isrunning()) 
{
    erreur = "RTC";
    //RTC.adjust(DateTime(__DATE__, __TIME__));//Décommenter pour initialiser l'heure
}

 attachInterrupt(0, rpm_fun, RISING); // LA fonction qui compte les tours de roues en background

 rpmcount = 0;
 rpm = 0;
 timeold = 0;
}

void loop() {
DateTime now = RTC.now();
if (rpmcount >= 10) { 
   //Update RPM every 10 counts, increase this for better RPM resolution,
   //decrease for faster update
   rpm = 30*1000/(millis() - timeold)*rpmcount;
   timeold = millis();
   rpmcount = 0;
   vitesse= rpm*60;
   vitesse= vitesse*2.10;
   intVitesse = vitesse/1000;

   File dataFile = SD.open("datalog.txt", FILE_WRITE); // on ecrit le nombre de km parcourus dans un fichier
    // if the file is available, write to it:
if (dataFile) {
  dataFile.seek(0);
  dataFile.print(kmcount);
  dataFile.close();
}  
// if the file isn't open, pop up an error:
else {
 erreur = "File"; //error opening datalog.txt
} 
 }

//acquisition de la valeur analogique dans sensorValue
// de 0 à 1023 -> 0 à 5V
int sensorValue = analogRead(tmpPin); 


//transformation en milliVolts dans outputValue
float outputValue = (((float)(sensorValue))*5000.0)/1023.0;

//Calcul de la température en fonction des milliVolts
float outputTemp = ( (float) outputValue - 500.0) /10.0;

//insertion de la température dans le tableau
temperature[index] = outputTemp;

//incrémentation de l'index modulo 10
index = (index + 1) % 10;

// calcul de la moyenne ( Méthode barbare, une boucle for l'aurait mieux fait)  
int tempMoy = (temperature[0]+temperature[1]+temperature[2]+temperature[3]+temperature[4]+temperature[5]+temperature[6]+temperature[7]+temperature[8]+temperature[9])/10;

lcd.setCursor(0, 0);
bigFont(intVitesse); // affichage de la vitesse en gros, fonctionne seulement si inferieur a 999!

int jaugeValue = analogRead(jaugePin); // lecture de la jauge
jaugeValue = map(jaugeValue, 500, 1000, 0, 5); 
if (lastJauge != jaugeValue) // si le niveau à bougé, on update l'affichage
{
lastJauge = jaugeValue;
lcd.setCursor(11, 1);
lcd.write(byte(1));
lcd.write(byte(4));
lcd.write(byte(4));
lcd.write(byte(4));
lcd.write(byte(2));
lcd.setCursor(11, 1);
int i=0;
while ( i < jaugeValue){
    lcd.write(byte(3));
    i++;
 } 
}
// on gere l'affichage des options heure et temperature
  unsigned long currentMillis = millis();
  if(currentMillis - previousMillis > interval) {
  lcdState ++;


  previousMillis = currentMillis;   

  }
  lcd.setCursor(11, 0);
  if(erreur=="")
  {
  if(lcdState == 0){//affichage de l'heure
    lcd.print(now.hour());
    lcd.print(":");
    lcd.print(now.minute());

  }
  else if(lcdState == 1){//affichage de la temperature moyenne exterieur
    lcd.print("  ");
    lcd.print(tempMoy);
lcd.setCursor(15, 0);
lcd.write(byte(0));
  }
  else if(lcdState == 2){//affichage de la température moteur
    lcd.print("  ");
    lcd.print(tempMoy+(tempMoy*272)/100);//Cette partie est simulée tant que je n'ai pas cablé le thermocouple
lcd.setCursor(15, 0);
lcd.write(byte(0));
  }
  else{

    lcdState = 0;
  }
  }
  else
  {
    if(erreur == "Init")
    {
      lcd.print(erreur);
      delay(700);
      lcd.setCursor(11, 0);

      lcd.print(".");
      delay(700);
      lcd.print(".");
      delay(700);
      lcd.print(".");
      delay(700);
      lcd.print(".");
      delay(700);
      lcd.print(".");
      delay(700);
    erreur = "";

    }
    lcd.print(erreur);
    
  }
delay(30); // un petit delais pour ne pas trop mouliner

}

void rpm_fun()
{
 rpmcount++;
 kmcount= kmcount + 0.0021;
}